{
  "version": 3,
  "sources": ["../../../dom/lifecycle.ts", "../../../dom/store.ts", "../../../dom.ts"],
  "sourcesContent": ["import {\n  call,\n  dispatchPrevented,\n  eventType,\n  forEach,\n  listen,\n  reverseForOf,\n  stopPropagation,\n} from \"./util.ts\";\n\nconst trackEvent = eventType<() => void>({ type: \"lf-t\" });\nconst untrackEvent = eventType({ type: \"lf-u\" });\n\n// Registers a lifecycle-tracking Node\nexport const trackChildren = (node: Node) => {\n  let nodes = new Map<EventTarget, Set<() => void>>(),\n    trackUnsub = listen(node, trackEvent, (e) => {\n      let t = e.target!,\n        cs = nodes.get(t);\n      if (t != node) {\n        stopPropagation(e);\n        if (!cs) nodes.set(t, cs = new Set());\n        cs.add(e.detail);\n      }\n    }),\n    untrackUnsub = listen(node, untrackEvent, (e) => {\n      let t = e.target!,\n        cleanups = nodes.get(t);\n      if (t != node) {\n        stopPropagation(e);\n        forEach(cleanups, call);\n        nodes.delete(t);\n      }\n    }),\n    cleanup = () => {\n      reverseForOf(nodes.values(), (cleanups) => reverseForOf(cleanups, call));\n      untrackUnsub();\n      trackUnsub();\n      nodes.clear();\n    };\n\n  registerCleanup(node, cleanup);\n  return cleanup;\n};\n\n// Tells the closest lifecycle-tracking parent to attach a cleanup to a Node\nexport const registerCleanup = (node: EventTarget, cleanup: () => void) => {\n  dispatchPrevented(node, trackEvent(cleanup));\n};\n\nexport const cleanup = (node: EventTarget) =>\n  dispatchPrevented(node, untrackEvent());\n", "import { call, entries, forEach, isFunction } from \"./util.ts\";\n\ntype JSONLiteral = string | number | boolean | null;\n\ntype JSONRecord = {\n  [member: string]: JSONLiteral | JSONArray | JSONRecord | undefined; // In order to handle optional properties\n};\n\ntype JSONArray = ReadonlyArray<JSONLiteral | JSONArray | JSONRecord>;\n\nexport type JSONable = JSONLiteral | JSONRecord | JSONArray;\n\ntype ResourceStore = Record<string, StoredResource | undefined>;\n\ntype StoredResource = [JSONable | undefined, Set<ResourceListener>];\n\ntype ResourceListener = () => void;\n\nconst storeRecords: ResourceStore = {};\n\nexport type StoreAPI = Readonly<typeof store>;\n\nexport const store = {\n  peek: (uri: string): JSONable | undefined => storeRecords[uri]?.[0],\n\n  sub: (uris: readonly string[], cb: ResourceListener): () => void => {\n    forEach(\n      uris,\n      (uri) => (storeRecords[uri] ??= [undefined, new Set()])![1].add(cb),\n    );\n    return () => forEach(uris, (uri) => storeRecords[uri]![1].delete(cb));\n  },\n\n  set: (\n    resources: Record<\n      string,\n      | JSONable\n      | undefined\n      | ((prev: JSONable | undefined) => JSONable | undefined)\n    >,\n  ): () => void => {\n    let batch = new Set<ResourceListener>(),\n      rollbacks: (() => void)[] = [],\n      setValue = (uri: string, v: JSONable | undefined) => {\n        let changed = 0,\n          r = (storeRecords[uri] ??= [undefined, new Set()]),\n          prev = r[0];\n        if (v !== prev) {\n          r[0] = v;\n          forEach(r[1], (cb) => batch.add(cb));\n          rollbacks.push(() => {\n            if (r[0] === v) setValue(uri, prev);\n          });\n          changed = 1;\n        }\n        if (v === undefined) delete storeRecords[uri];\n        return changed;\n      };\n\n    forEach(\n      entries(resources),\n      ([uri, v]) => setValue(uri, isFunction(v) ? v(store.peek(uri)) : v),\n    );\n    forEach(batch, call);\n\n    return () => {\n      batch = new Set();\n      forEach(rollbacks, call);\n      forEach(batch, call);\n    };\n  },\n};\n", "import { registerCleanup } from \"./dom/lifecycle.ts\";\nimport { store } from \"./dom/store.ts\";\nimport { isFunction } from \"./dom/util.ts\";\n\n/**\n * Tuple holding refs attached to a jsx tree render.\n * First holds node index, second represents: children if present, otherwise (undefined) means next ref is associated.\n */\nexport type Activation = ([number] | [number, Activation])[];\n\nlet i;\n\nconst refs = (\n  node: ChildNode,\n  activatedLength: number,\n  activation: Activation,\n): readonly EventTarget[] => {\n  for (i = 0; i < activatedLength; i++) node = node.previousSibling!;\n  i = 0;\n  return walkRefs(node, activation);\n};\n\nconst walkRefs = (\n  node: ChildNode,\n  activation: Activation,\n): readonly EventTarget[] =>\n  activation.flatMap(([childIndex, sub]) => {\n    for (; i! < childIndex; i!++) node = node.nextSibling!;\n    return sub ? walkRefs(node.firstChild!, sub) : node;\n  });\n\nconst sub = (\n  target: EventTarget,\n  cb: () => void | (() => void),\n  uris?: readonly string[],\n): void => {\n  let cleanup: (() => void) | void = cb(),\n    unsubStore = uris && store.sub(uris, () => {\n      isFunction(cleanup) && cleanup();\n      cleanup = cb();\n    });\n  registerCleanup(\n    target,\n    () => {\n      unsubStore?.();\n      isFunction(cleanup) && cleanup();\n    },\n  );\n};\n\n/*\n * Effect API\n */\nexport { refs, store, sub };\n"],
  "mappings": "AAAA,OACE,QAAAA,EACA,qBAAAC,EACA,aAAAC,EACA,WAAAC,EACA,UAAAC,EACA,gBAAAC,EACA,mBAAAC,MACK,+BAEP,IAAMC,EAAaL,EAAsB,CAAE,KAAM,MAAO,CAAC,EACnDM,EAAeN,EAAU,CAAE,KAAM,MAAO,CAAC,EAmCxC,IAAMO,EAAkB,CAACC,EAAmBC,IAAwB,CACzEC,EAAkBF,EAAMG,EAAWF,CAAO,CAAC,CAC7C,EChDA,OAAS,QAAAG,EAAM,WAAAC,EAAS,WAAAC,EAAS,cAAAC,MAAkB,+BAkBnD,IAAMC,EAA8B,CAAC,EAIxBC,EAAQ,CACnB,KAAOC,GAAsCF,EAAaE,CAAG,IAAI,CAAC,EAElE,IAAK,CAACC,EAAyBC,KAC7BN,EACEK,EACCD,IAASF,EAAaE,CAAG,IAAM,CAAC,OAAW,IAAI,GAAK,GAAI,CAAC,EAAE,IAAIE,CAAE,CACpE,EACO,IAAMN,EAAQK,EAAOD,GAAQF,EAAaE,CAAG,EAAG,CAAC,EAAE,OAAOE,CAAE,CAAC,GAGtE,IACEC,GAMe,CACf,IAAIC,EAAQ,IAAI,IACdC,EAA4B,CAAC,EAC7BC,EAAW,CAACN,EAAaO,IAA4B,CACnD,IAAIC,EAAU,EACZC,EAAKX,EAAaE,CAAG,IAAM,CAAC,OAAW,IAAI,GAAK,EAChDU,EAAOD,EAAE,CAAC,EACZ,OAAIF,IAAMG,IACRD,EAAE,CAAC,EAAIF,EACPX,EAAQa,EAAE,CAAC,EAAIP,GAAOE,EAAM,IAAIF,CAAE,CAAC,EACnCG,EAAU,KAAK,IAAM,CACfI,EAAE,CAAC,IAAMF,GAAGD,EAASN,EAAKU,CAAI,CACpC,CAAC,EACDF,EAAU,GAERD,IAAM,QAAW,OAAOT,EAAaE,CAAG,EACrCQ,CACT,EAEF,OAAAZ,EACED,EAAQQ,CAAS,EACjB,CAAC,CAACH,EAAKO,CAAC,IAAMD,EAASN,EAAKH,EAAWU,CAAC,EAAIA,EAAER,EAAM,KAAKC,CAAG,CAAC,EAAIO,CAAC,CACpE,EACAX,EAAQQ,EAAOV,CAAI,EAEZ,IAAM,CACXU,EAAQ,IAAI,IACZR,EAAQS,EAAWX,CAAI,EACvBE,EAAQQ,EAAOV,CAAI,CACrB,CACF,CACF,ECrEA,OAAS,cAAAiB,MAAkB,+BAQ3B,IAAIC,EAEEC,EAAO,CACXC,EACAC,EACAC,IAC2B,CAC3B,IAAKJ,EAAI,EAAGA,EAAIG,EAAiBH,IAAKE,EAAOA,EAAK,gBAClD,OAAAF,EAAI,EACGK,EAASH,EAAME,CAAU,CAClC,EAEMC,EAAW,CACfH,EACAE,IAEAA,EAAW,QAAQ,CAAC,CAACE,EAAYC,CAAG,IAAM,CACxC,KAAOP,EAAKM,EAAYN,IAAME,EAAOA,EAAK,YAC1C,OAAOK,EAAMF,EAASH,EAAK,WAAaK,CAAG,EAAIL,CACjD,CAAC,EAEGK,EAAM,CACVC,EACAC,EACAC,IACS,CACT,IAAIC,EAA+BF,EAAG,EACpCG,EAAaF,GAAQG,EAAM,IAAIH,EAAM,IAAM,CACzCX,EAAWY,CAAO,GAAKA,EAAQ,EAC/BA,EAAUF,EAAG,CACf,CAAC,EACHK,EACEN,EACA,IAAM,CACJI,IAAa,EACbb,EAAWY,CAAO,GAAKA,EAAQ,CACjC,CACF,CACF",
  "names": ["call", "dispatchPrevented", "eventType", "forEach", "listen", "reverseForOf", "stopPropagation", "trackEvent", "untrackEvent", "registerCleanup", "node", "cleanup", "dispatchPrevented", "trackEvent", "call", "entries", "forEach", "isFunction", "storeRecords", "store", "uri", "uris", "cb", "resources", "batch", "rollbacks", "setValue", "v", "changed", "r", "prev", "isFunction", "i", "refs", "node", "activatedLength", "activation", "walkRefs", "childIndex", "sub", "target", "cb", "uris", "cleanup", "unsubStore", "store", "registerCleanup"]
}
