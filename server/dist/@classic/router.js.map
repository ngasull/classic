{
  "version": 3,
  "sources": ["../../client-router.ts"],
  "sourcesContent": ["import {\n  adoptNode,\n  call,\n  doc,\n  domParse,\n  forEach,\n  listen,\n  location,\n  preventDefault,\n  Promise,\n  querySelector,\n  querySelectorAll,\n  remove,\n  replaceWith,\n  TRUE,\n  win,\n} from \"@classic/js/dom/util\";\n\nconst suspenseDelay = 500;\n\nlet currentNavigateQ: Promise<unknown> | 0;\nlet fetchCache: Record<string, Document | undefined> = {};\n\nconst ccRoute = \"cc-route\";\nconst fetchingClass = \"cc-fetching\";\n\nconst navigate = async (href: string) => {\n  let url = new URL(href, location.origin),\n    rootSlot = querySelector(ccRoute)!,\n    slot = rootSlot,\n    child: Element | null,\n    pathAttr: string | null,\n    currentFrom: string[] = [], // Contains dynamic routes too\n    navigateQ: Promise<void | Document> | Document,\n    resQ: Promise<Document>,\n    resFrom: string | null,\n    rootClassList = document.documentElement.classList;\n\n  // Fallback to regular navigation if page defines no route\n  if (!rootSlot) navigateFallback(href);\n\n  while ((child = querySelector(ccRoute, slot))) {\n    pathAttr = slot.getAttribute(\"path\");\n    if (!pathAttr) break;\n    currentFrom.push(pathAttr);\n    slot = child;\n  }\n\n  url.searchParams.set(\"cc-from\", currentFrom.join(\"/\"));\n\n  navigateQ = currentNavigateQ = Promise.race([\n    new Promise<void>((resolve) => setTimeout(resolve, suspenseDelay)),\n    resQ = Promise.resolve(\n      fetchCache[url as any]?.cloneNode(TRUE) as Document ??\n        fetch(url).then((res): Promise<Document> =>\n          res.redirected ? Promise.reject(navigate(res.url)) : (\n            resFrom = res.headers.get(\"CC-From\"),\n              res.text().then((html) =>\n                currentNavigateQ == navigateQ\n                  ? domParse(html)\n                  : Promise.reject()\n              )\n          )\n        ),\n    ).finally(() => currentNavigateQ = 0),\n  ]);\n\n  if (location.href != href) history.pushState(0, \"\", href);\n\n  if (!await navigateQ) rootClassList.add(fetchingClass);\n\n  let receivedDoc = await resQ,\n    receivedSlot = querySelector(ccRoute, receivedDoc.body),\n    title = receivedDoc.title,\n    currentHead: Record<string, Element> = {},\n    i = 0,\n    seg: string;\n\n  remove(rootClassList, fetchingClass);\n\n  if (!receivedSlot) navigateFallback(href);\n\n  // ! \\\\ `reqQ` needs to be awaited from here, so `resFrom` is available\n  // ! \\\\ If `resFrom` is null, it means SSG or cache result\n  slot = rootSlot;\n  for (seg of resFrom! ? resFrom.split(\"/\") : []) {\n    // We must already have all the layouts assumed by CC-From\n    if (\n      seg != currentFrom[i] ||\n      !(slot = querySelector(ccRoute, slot)!)\n    ) navigateFallback(href);\n    i++;\n  }\n\n  if (!slot) navigateFallback(href);\n\n  if (title) doc.title = title;\n\n  forEachSourceable(doc.head, (el, key) => currentHead[key] = el);\n  forEachSourceable(\n    receivedDoc.head,\n    (el, key) => !currentHead[key] && doc.head.append(adoptNode(el)),\n  );\n\n  replaceWith(slot, adoptNode(receivedSlot!));\n\n  // Scripts parsed with DOMParser are not marked to be run\n  forEach(\n    querySelectorAll<HTMLScriptElement>(\"script\", receivedSlot!),\n    reviveScript,\n  );\n};\n\nconst navigateFallback = (href: string) => {\n  throw location.href = href;\n};\n\nconst forEachSourceable = (\n  head: HTMLHeadElement,\n  cb: (el: HTMLLinkElement | HTMLScriptElement, key: string) => void,\n) =>\n  forEach(\n    querySelectorAll<HTMLLinkElement | HTMLScriptElement>(\n      `link,script`,\n      head,\n    ),\n    (el, tagName?: any) =>\n      cb(\n        el,\n        `${tagName = el.tagName}:${\n          tagName == \"LINK\"\n            ? (el as HTMLLinkElement).href\n            : (el as HTMLScriptElement).src\n        }`,\n      ),\n  );\n\nconst reviveScript = (script: HTMLScriptElement) => {\n  let copy = doc.createElement(\"script\");\n  copy.text = script.text;\n  replaceWith(script, copy);\n};\n\nconst isLocal = (href: string) => {\n  let origin = location.origin;\n  return new URL(href, origin).origin == origin;\n};\n\nexport const init = (): () => void => {\n  let t: EventTarget | null,\n    subs: Array<() => void> = [\n      listen(\n        doc.body,\n        \"click\",\n        (e) =>\n          !e.ctrlKey &&\n          !e.shiftKey &&\n          (t = e.target) instanceof HTMLAnchorElement &&\n          isLocal(t.href) && (preventDefault(e), navigate(t.href)),\n      ),\n\n      listen(\n        doc.body,\n        \"submit\",\n        (e) =>\n          (t = e.target) instanceof HTMLFormElement &&\n          t.method == \"get\" &&\n          !e.defaultPrevented &&\n          isLocal(t.action) && (preventDefault(e), navigate(t.action)),\n      ),\n\n      listen(win, \"popstate\", () => navigate(location.href)),\n    ];\n\n  return () => subs.map(call);\n};\n"],
  "mappings": "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",
  "names": ["adoptNode", "call", "doc", "domParse", "forEach", "listen", "location", "preventDefault", "Promise", "querySelector", "querySelectorAll", "remove", "replaceWith", "TRUE", "win", "suspenseDelay", "currentNavigateQ", "fetchCache", "ccRoute", "fetchingClass", "navigate", "href", "url", "rootSlot", "slot", "child", "pathAttr", "currentFrom", "navigateQ", "resQ", "resFrom", "rootClassList", "navigateFallback", "resolve", "res", "html", "receivedDoc", "receivedSlot", "title", "currentHead", "i", "seg", "forEachSourceable", "el", "key", "reviveScript", "head", "cb", "tagName", "script", "copy", "isLocal", "origin", "init", "t", "subs", "e"]
}
